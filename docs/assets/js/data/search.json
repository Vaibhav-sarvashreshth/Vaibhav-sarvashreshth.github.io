[
  
  {
    "title": "Top 50 Graph Questions",
    "url": "/posts/Priority-Queue/",
    "categories": "GRAPH",
    "tags": "top-50-graph-question, Imp-graph_questions, DFS, BFS",
    "date": "2023-06-06 22:48:18 +0530",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "Top 50 Graph Questions",
    "url": "/posts/Top-50-Graph-Questions/",
    "categories": "GRAPH",
    "tags": "top-50-graph-question, Imp-graph_questions, DFS, BFS",
    "date": "2023-05-16 22:48:18 +0530",
    





    
    "snippet": "Top 50 Graph ProblemsLooking to master graph theory and solve graph problems efficiently? You’re in the right place! This blog provides solutions to the top 50 graph problems along with multiple ap...",
    "content": "Top 50 Graph ProblemsLooking to master graph theory and solve graph problems efficiently? You’re in the right place! This blog provides solutions to the top 50 graph problems along with multiple approaches for each problem. We also ensure that the written code is well-commented for better understanding.Graphs are essential data structures used in various fields, including computer science, data analysis, and network analysis. By gaining proficiency in graph theory and problem-solving, you can enhance your skills and tackle complex challenges effectively.Graph Problem HeadingPrint adjacency listGiven the adjacency list of a bidirectional graph. Your task is to copy/clone the adjacency list for each vertex and return a new list.SolutionDiscuss the first solution to the graph problem. Explain the approach, algorithm, or technique used in this solution. Provide step-by-step explanations, highlighting any key insights or observations.Code (C++)vector&lt;vector&lt;int&gt;&gt; printGraph(int V, vector&lt;int&gt; adj[])    {        vector&lt;vector&lt;int&gt;&gt; graph(V);        int k=0;        while(k&lt;V)        {            graph[k].push_back(k);            k++;        }        for(int i=0;i&lt;V;i++)        {            for(int x : adj[i])            {                graph[i].push_back(x);            }        }        return graph;    }BFS of graphGiven a directed graph. The task is to do Breadth First Traversal of this graph starting from 0.Note: One can move from node u to node v only if there’s an edge from u to v and find the BFS traversal of the graph starting from the 0th vertex, from left to right according to the graph. Also, you should only take nodes directly or indirectly connected from Node 0 in consideration.Solutionvector&lt;int&gt; bfsOfGraph(int V, vector&lt;int&gt; adj[])    {        // Vector to store the nodes visited in BFS order        vector&lt;int&gt; nodes;        // Array to keep track of visited nodes        int visited[V] = {false};        // Create a queue for BFS traversal        queue&lt;int&gt; q;        // Start BFS from vertex 0        q.push(0);        visited[0] = true;        // Perform BFS traversal        while (!q.empty())        {            int front = q.front();            nodes.push_back(front);            q.pop();            // Traverse all adjacent nodes of the current node            for (auto node : adj[front])            {                // If the adjacent node is not visited, mark it as visited,                // add it to the visited nodes vector, and enqueue it for further traversal                if (!visited[node])                {                    visited[node] = true;                    q.push(node);                }            }        }        // Return the vector containing the nodes visited in BFS order        return nodes;    }DFS of GraphYou are given a connected undirected graph. Perform a Depth First Traversal of the graph.Note: Use a recursive approach to find the DFS traversal of the graph starting from the 0th vertex from left to right according to the graph.Solution/* * Depth First Traversal (DFS) of a Graph * * This code implements a recursive approach to perform a Depth First Traversal (DFS) of a connected undirected graph. * The DFS traversal starts from the 0th vertex and explores all reachable vertices from each visited vertex. * The traversal order is from left to right according to the graph. */#include &lt;vector&gt;using namespace std;// Recursive function to perform DFS traversalvoid dfsrec(vector&lt;int&gt; adj[], int i, vector&lt;bool&gt;&amp; visited, vector&lt;int&gt;&amp; ans) {    /* If the current vertex is already visited, return */    if (visited[i]) {        return;    }    /* Mark the current vertex as visited */    visited[i] = true;    /* Add the current vertex to the result */    ans.push_back(i);    /* Traverse all adjacent vertices of the current vertex */    for (int u : adj[i]) {        /* If the adjacent vertex is not visited, recursively call the DFS function */        if (!visited[u]) {            dfsrec(adj, u, visited, ans);        }    }}// Function to find the DFS traversal of the graphvector&lt;int&gt; dfsOfGraph(int V, vector&lt;int&gt; adj[]) {    vector&lt;int&gt; ans;    vector&lt;bool&gt; visited(V, false);    /* Traverse all vertices of the graph */    for (int i = 0; i &lt; V; i++) {        /* If the current vertex is not visited, call the DFS function */        if (!visited[i]) {            dfsrec(adj, i, visited, ans);        }    }    return ans;}Find the number of islandsGiven a grid of size n*m (n is the number of rows and m is the number of columns in the grid) consisting of ‘0’s (Water) and ‘1’s(Land). Find the number of islands.Note: An island is either surrounded by water or boundary of grid and is formed by connecting adjacent lands horizontally or vertically or diagonally i.e., in all 8 directions.Solution (using BFS)#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;// Breadth-First Search (BFS) functionvoid bfs(vector&lt;vector&lt;int&gt;&gt;&amp; adj, int V, int N, bool* visited) {queue&lt;int&gt; q;visited[N] = true;q.push(N);while (!q.empty()) {    int top = q.front();    q.pop();    for (int i = 0; i &lt; V; i++) {        if (!visited[i] &amp;&amp; adj[top][i]) {            q.push(i);            visited[i] = true;        }    }}}// Function to find the number of provinces in the graphint numProvinces(vector&lt;vector&lt;int&gt;&gt;&amp; adj, int V) {bool visited[V] = { false };int no_of_provinces = 0;for (int i = 0; i &lt; V; i++) {    if (!visited[i]) {        bfs(adj, V, i, visited);        no_of_provinces++;    }}return no_of_provinces;}Solution (using DFS)void dfs(int index, vector&lt;vector&lt;int&gt;&gt; adj, int visited[], int V)    {        visited[index] = 1;                for(int i = 0; i &lt; V; i++)        {            if(adj[index][i] and visited[i] == 0)            {                visited[i] = 1;                dfs(i, adj, visited, V);            }        }    }        int numProvinces(vector&lt;vector&lt;int&gt;&gt; adj, int V) {                int visited[V] = {0};        int comp = 0;                for(int i = 0; i &lt; V; i++)        {            if(!visited[i])            {                comp++;                dfs(i, adj, visited, V);            }        }                return comp;    }Find the number of islandsGiven a grid of size n*m (n is the number of rows and m is the number of columns in the grid) consisting of ‘0’s (Water) and ‘1’s(Land). Find the number of islands.Note: An island is either surrounded by water or boundary of grid and is formed by connecting adjacent lands horizontally or vertically or diagonally i.e., in all 8 directions.Solutionint vis[501][501]=0;    int n,m;    int dx[8] = { -1, 1, 0, 0, -1, -1, 1, 1};    int dy[8] = {0, 0, -1, 1, -1, 1, -1, 1};        bool val(int r,int c)    {        if(r&lt;0 || r&gt;=n || c&lt;0 || c&gt;=m)        {            return 0;        }        else        {            return 1;        }    }        void dfs(int r,int c)    {        vis[r][c]=1;        for(int i=0;i&lt;8;i++)        {            int nr=r+dx[i];            int nc=c+dy[i];            if(val(nr,nc) &amp;&amp; vis[nr][nc]==0)            {                dfs(nr,nc);                            }        }    }        int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid)    {        // Code here        n=grid.size();        m=grid[0].size();                int no_of_island=0;                for(int i=0;i&lt;n;i++)        {            for(int j=0;j&lt;m;j++)            {                if(grid[i][j]=='0')                {                    vis[i][j]=1;                }            }        }        for(int i=0;i&lt;n;i++)        {            for(int j=0;j&lt;m;j++)            {                if(!vis[i][j])                {                    dfs(i,j);                    no_of_island++;                }               }        }        return no_of_island;            }Detect cycle in an undirected graphGiven an undirected graph with V vertices and E edges, check whether it contains any cycle or not. Graph is in the form of adjacency list where adj[i] contains all the nodes ith node is having edge with.Solution#include &lt;vector&gt;using namespace std;// Depth-First Search (DFS) functionbool dfs(vector&lt;int&gt; adj[], vector&lt;bool&gt;&amp; visited, int source, int parent) {visited[source] = true;for (auto node : adj[source]) {    if (visited[node] == false) {        if (dfs(adj, visited, node, source)) {            return true;        }    } else if (node != parent) {        return true;    }}return false;}// Function to check whether the graph contains any cyclebool isCycle(int V, vector&lt;int&gt; adj[]) {vector&lt;bool&gt; visited(V, false);for (int i = 0; i &lt; V; i++) {    if (visited[i] == false) {        if (dfs(adj, visited, i, -1)) {            return true;        }    }}return false;}Hamiltonian PathA Hamiltonian path, is a path in an undirected graph that visits each vertex exactly once. Given an undirected graph, the task is to check if a Hamiltonian path is present in it or not.Solution bool dfs(int n, vector&lt;int&gt; adj[], vector&lt;int&gt; &amp;vist, int src){        if(n==0){            return true;        }        vist[src]=1;        for(auto &amp;x:adj[src]){            if(vist[x]==0){                if(dfs(n-1,adj,vist,x)){                    return true;                }            }        }        vist[src]=0;        return false;    }    bool check(int N,int M,vector&lt;vector&lt;int&gt;&gt; Edges)    {        // code here        int n= N, m= M;        vector&lt;int&gt; adj[n];                for(auto &amp;x:Edges){            adj[x[0]-1].push_back(x[1]-1);            adj[x[1]-1].push_back(x[0]-1);        }                vector&lt;int&gt; vist(n,0);                for(int i=0;i&lt;n;i++){            if(dfs(n-1,adj,vist,i)){                return true;            }        }        return false;    }Prerequisite TasksThere are a total of N tasks, labeled from 0 to N-1. Some tasks may have prerequisites, for example to do task 0 you have to first complete task 1, which is expressed as a pair: [0, 1]Given the total number of tasks N and a list of prerequisite pairs P, find if it is possible to finish all tasks.Solutionbool isPossible(int N, vector&lt;pair&lt;int, int&gt; &gt;&amp; prerequisites) {\t    // Code here\t    \t    int n = N;\t    \t    vector&lt;vector&lt;int&gt;&gt; graph(n);        vector&lt;int&gt; indegree(n,0);        for(auto c : prerequisites)        {            graph[c.second].push_back(c.first);            indegree[c.first]++;        }                vector&lt;int&gt; toposort;        queue&lt;int&gt; q;        for(int i=0;i&lt;n;i++)        {            if(indegree[i]==0)                 q.push(i);        }        while(!q.empty())        {            int curr = q.front();            q.pop();            toposort.push_back(curr);                        for(auto nbr: graph[curr])            {                indegree[nbr]--;                if(indegree[nbr]==0)                     q.push(nbr);            }        }        if(toposort.size()!=n)         \treturn false;        \t        return true;\t}Course ScheduleThere are a total of n tasks you have to pick, labeled from 0 to n-1. Some tasks may have prerequisites tasks, for example to pick task 0 you have to first finish tasks 1, which is expressed as a pair: [0, 1]Given the total number of n tasks and a list of prerequisite pairs of size m. Find a ordering of tasks you should pick to finish all tasks.Note: There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all tasks, return an empty array. Returning any correct order will give the output as 1, whereas any invalid order will give the output “No Ordering Possible”.Solutionbool dfs(int i ,vector&lt;vector&lt;int&gt;&gt; &amp;adj,vector&lt;int&gt; &amp;visited , vector&lt;int&gt; &amp;recursive_stack ,stack&lt;int&gt;&amp;answer)    {         recursive_stack[i]= true;         visited[i]=true;                 for(auto node: adj[i])        {                        if(!visited[node])            {                if(dfs(node,adj,visited,recursive_stack,answer))                {                    return true;                }                            }            else if(recursive_stack[node]==true)            {                return true;            }                                }        answer.push(i);        recursive_stack[i]= false;                return false;    }            vector&lt;int&gt; findOrder(int n, int m, vector&lt;vector&lt;int&gt;&gt; prerequisites)     {        //code here        vector&lt;int&gt;ordering;        vector&lt;int&gt;visited(n,0),recursive_stack(n,0);\t    \t    vector&lt;vector&lt;int&gt;&gt; adj(n);\t    stack&lt;int&gt;answer;\t    \t    // converting the list into adj matrix\t     for (auto&amp; prerequisite : prerequisites) {            int course = prerequisite[0];            int prerequisiteCourse = prerequisite[1];            adj[prerequisiteCourse].push_back(course);        }\t    \t    \t    // now traversing through adj using dfs\t    \t    for(int i=0;i&lt;n;i++)\t    {\t        if(!visited[i])\t        {\t            if(dfs(i,adj,visited,recursive_stack,answer))\t            {\t                \t                return {};\t            }\t        }\t    }\t    \t    while (!answer.empty()) {            ordering.push_back(answer.top());            answer.pop();        }        return ordering;                            }Circle of stringsGiven an array of lowercase strings A[] of size N, determine if the strings can be chained together to form a circle.A string X can be chained together with another string Y if the last character of X is same as firstcharacter of Y. If every string of the array can be chained, it will form a circle.For example, for the array arr[] = {“for”, “geek”, “rig”, “kaf”} the answer will be Yes as the given strings can be chained as “for”, “rig”, “geek” and “kaf”Solutionvoid dfs(int node, vector&lt;int&gt; adj[], vector&lt;int&gt; &amp;vis){     vis[node]=1;          for(auto child: adj[node]){         if(vis[child]==0){             dfs(child,adj,vis);         }     }    }    int isCircle(int N, vector&lt;string&gt; A)    {                int n= N;        vector&lt;int&gt; adj[26];        vector&lt;int&gt; in(26,0), out(26,0);                for(int i=0;i&lt;n;i++){            int ch1=A[i][0]-'a';            int ch2=A[i].back()-'a';                        adj[ch1].push_back(ch2); //linking all componenets to form a eulerian cycle and test later            in[ch2]++;            out[ch1]++;        }                vector&lt;int&gt; vis(26,0);         int src=0;                        for(int i=0;i&lt;26;i++){            if(in[i]!=out[i]){                return 0;            }        }        for(int i=0;i&lt;26;i++){            if(out[i]!=0){                src=i;                break;            }        }                dfs(src,adj,vis);                for(int i=0;i&lt;26;i++){            if(vis[i]==0 &amp;&amp; out[i]){                return 0;            }        }                return 1;    }** **SolutionFurther Improvement / readingtext"
  },
  
  {
    "title": "Database Sharding",
    "url": "/posts/hello-homelab/",
    "categories": "DBMS",
    "tags": "sharding, Horizontal sharding, Vertical sharding, types of sharding",
    "date": "2023-05-16 22:48:18 +0530",
    





    
    "snippet": "What is Database ShardingSharding is a type of database partitioning that separates large databases into smaller, faster, more easily managed parts. These smaller parts are called data shards. The ...",
    "content": "What is Database ShardingSharding is a type of database partitioning that separates large databases into smaller, faster, more easily managed parts. These smaller parts are called data shards. The word shard means “a small part of a whole.”Horizontal Vs vertical sharding:To achieve sharding, the rows or columns of a larger database table are split into multiple smaller tables.When we split using rows : Horizontal ShardingWhen we split using columns : Vertical ShardingHorizontal sharding.When each new table has the same schema but unique rows, it is known as horizontal sharding. In this type of sharding, more machines are added to an existing stack to spread out the load, increase processing speed and support more traffic. This method is most effective when queries return a subset of rows that are often grouped together.Vertical sharding.When each new table has a schema that is a faithful subset of the original table’s schema, it is known as vertical sharding. It is effective when queries usually return only a subset of columns of the data.Original data set :            Student ID      Name      Age      Major      Hometown                  1      Amy      21      Economics      Austin              2      Jack      20      History      San Francisco              3      Matthew      22      Political Science      New York City              4      Priya      19      Biology      Gary              5      Ahmed      19      Philosophy      Boston      Horizontal Shardingshard 1            Student ID      Name      Age      Major      Hometown                  1      Amy      21      Economics      Austin              2      Jack      20      History      San Francisco      shard 2            Student ID      Name      Age      Major      Hometown                  3      Matthew      22      Political Science      New York City              4      Priya      19      Biology      Gary              5      Ahmed      19      Philosophy      Boston      Vertical Shardingshard 1            Student ID      Name      Age                  1      Amy      21              2      Jack      20      shard 2            Student ID      Major                  1      Economics              2      History      shard 3            Student ID      Hometown                  1      Austin              2      San Francisco      Benifits of Sharding  Horizontal scaling, also known as scaling out, enables flexible database design and is beneficial for parallel processing.      It provides near-limitless scalability for intense workloads and big data requirements.      Horizontal sharding optimizes the use of compute resources across a cluster for every query.      Query resolution is faster as each machine has to scan fewer rows.        Vertical sharding enhances a single machine’s capacity by increasing RAM, storage, and CPU capacity.        Sharded databases offer higher availability and mitigate the impact of outages.        During an outage, only the portions of an application relying on the missing data chunks become unusable.      Backup shards are replicated to additional nodes, minimizing damage from outages.      Applications without sharded databases may experience complete unavailability during an outage.    Sharding increases the read/write throughput when operations are limited to a single shard.Types of shardingRange-Based Sharding:  Range-Based Sharding involves partitioning data based on a specific range of values.  The shard key, which is a chosen attribute or column, determines the range for each shard.  Data is distributed to different shards based on the values falling within the defined ranges.  This approach is particularly useful when data can be naturally grouped or sorted based on a range, such as dates, numerical values, or geographical regions.  For example, in a customer database, you can shard data based on the customer’s last name initial, where each shard stores data for a specific range of last name initials (e.g., shard 1 for A-F, shard 2 for G-M, etc.).Hash-Based Sharding:  Hash-Based Sharding involves distributing data across shards using a hash function.  The shard key value is input into a hash function, which generates a hash value.  The hash value determines the shard where the data will be stored.  Hash-Based Sharding ensures an even distribution of data across shards and minimizes hotspots.  This method works well when the distribution of data is not inherently ordered or when you want to achieve a uniform distribution of data across shards.  For example, if you have a user database, you can use the user ID as the shard key and apply a hash function to determine which shard the user’s data will be stored on.Directory-Based Sharding  Directory-Based Sharding, also known as lookup-based sharding, involves using a directory or mapping table to determine the shard for a given key.  Each entry in the directory maps a key to its corresponding shard.  When a query or operation is performed, the directory is consulted to determine the shard responsible for handling that particular key.  This approach provides flexibility in managing shard assignments and allows for dynamic scaling and rebalancing of data across shards.  Directory-Based Sharding can be useful when the sharding criteria are not based on simple ranges or hash functions, but rather on more complex business logic or dynamically changing attributes.Strength and Consideration and which one is bestRange-Based Sharding:  Strengths:          Well-suited for data that can be naturally grouped or sorted based on ranges.      Enables efficient range-based queries and analysis.        Considerations:          Requires careful selection of the shard key to ensure balanced data distribution.      May encounter challenges when the data distribution is not evenly distributed across ranges.      Hash-Based Sharding:  Strengths:          Provides a uniform distribution of data across shards, minimizing hotspots.      Well-suited for scenarios where the distribution of data is not inherently ordered.        Considerations:          Can be challenging to perform range-based queries efficiently.      Requires consideration of hash collisions and their impact on performance.      Directory-Based Sharding:  Strengths:          Offers flexibility and dynamic scalability in managing shard assignments.      Allows for complex business logic and dynamic changes in shard assignments.        Considerations:          Introduces additional overhead due to the need to consult the directory for shard lookups.      Requires maintenance of the directory and its synchronization with shard assignments.      It’s important to note that the “best” sharding technique will depend on your specific use case, data characteristics, scalability requirements, and query patterns. Consider the following factors when making a decision:  Data Distribution: Analyze how your data is naturally distributed and identify any existing patterns or ranges that can be leveraged for sharding.  Query Patterns: Consider the types of queries performed on your data and assess how well each sharding technique aligns with those query patterns.  Scalability Requirements: Evaluate the scalability needs of your application and determine which sharding technique can provide the desired scalability and performance.  Flexibility and Maintenance: Consider the trade-offs between flexibility, maintenance, and complexity associated with each sharding technique.In practice, a combination of sharding techniques may be used depending on the specific requirements of different data sets or entities within your application. It’s recommended to thoroughly analyze your requirements, experiment, and benchmark the different techniques to determine the most suitable approach for your specific use case."
  }
  
]

